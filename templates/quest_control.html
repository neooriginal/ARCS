<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RoboCrew VR Control</title>
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <style>
        body {
            background-color: #111;
            color: #ccc;
            font-family: sans-serif;
        }

        #overlay {
            position: absolute;
            z-index: 1000;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <div id="overlay">
        <h2>ðŸ¤– RoboCrew VR</h2>
        <p><strong>Left Stick:</strong> Drive Robot</p>
        <p><strong>Right Hand:</strong> Move Arm (Delta Control)</p>
        <p><strong>Right Trigger:</strong> Close Gripper</p>
    </div>

    <a-scene background="color: transparent" renderer="alpha: true"
        webxr="optionalFeatures: local-floor, hand-tracking">
        <a-assets>
            <img id="camera-feed" src="/video_feed" crossorigin="anonymous">
        </a-assets>

        <!-- Camera feed display -->
        <a-plane src="#camera-feed" width="2.5" height="1.875" position="0 1.5 -1.8" auto-refresh-texture></a-plane>

        <!-- Camera Rig -->
        <a-entity id="rig" position="0 0 0">
            <a-camera position="0 1.6 0" look-controls="pointerLockEnabled: false"></a-camera>
            <a-entity id="leftHand" oculus-touch-controls="hand: left" robot-drive-controller></a-entity>
            <a-entity id="rightHand" oculus-touch-controls="hand: right" robot-arm-controller></a-entity>
        </a-entity>
    </a-scene>

    <script>
        const UPDATE_INTERVAL = 50; // 20Hz update rate

        // =============================================
        // SIMPLE 2-LINK INVERSE KINEMATICS
        // =============================================
        const ARM_LINK1 = 0.10; // Shoulder to elbow length (meters, approximate)
        const ARM_LINK2 = 0.12; // Elbow to wrist length (meters, approximate)

        function inverseKinematics(x, y) {
            // 2-link planar IK
            // x = forward distance, y = height in arm plane
            // Returns [shoulder_lift_deg, elbow_flex_deg]

            const L1 = ARM_LINK1;
            const L2 = ARM_LINK2;

            const dist = Math.sqrt(x * x + y * y);

            // Clamp to reachable workspace
            const maxReach = L1 + L2 - 0.01;
            const minReach = Math.abs(L1 - L2) + 0.01;
            const clampedDist = Math.max(minReach, Math.min(maxReach, dist));

            // Law of cosines for elbow angle
            let cosElbow = (L1 * L1 + L2 * L2 - clampedDist * clampedDist) / (2 * L1 * L2);
            cosElbow = Math.max(-1, Math.min(1, cosElbow));
            const elbowAngle = Math.acos(cosElbow); // 0 = straight, PI = fully bent

            // Shoulder angle
            const beta = Math.atan2(y, x);
            let cosAlpha = (L1 * L1 + clampedDist * clampedDist - L2 * L2) / (2 * L1 * clampedDist);
            cosAlpha = Math.max(-1, Math.min(1, cosAlpha));
            const alpha = Math.acos(cosAlpha);
            const shoulderAngle = beta + alpha;

            // Convert to degrees
            // shoulder_lift: 0 = horizontal, positive = up
            // elbow_flex: 0 = straight, negative = bent
            const shoulderLiftDeg = THREE.MathUtils.radToDeg(shoulderAngle) - 90;
            const elbowFlexDeg = -(180 - THREE.MathUtils.radToDeg(elbowAngle));

            return [shoulderLiftDeg, elbowFlexDeg];
        }

        // =============================================
        // DRIVE CONTROLLER (Left Hand)
        // =============================================
        AFRAME.registerComponent('robot-drive-controller', {
            init: function () {
                this.lastUpdate = 0;
                this.lastMovement = null;
            },
            tick: function () {
                if (!this.el.components['oculus-touch-controls']) return;
                const controller = this.el.components['oculus-touch-controls'].controller;
                if (!controller || !controller.gamepad) return;

                const gp = controller.gamepad;
                if (!gp.axes || gp.axes.length < 4) return;

                const x = gp.axes[2] || 0;
                const y = gp.axes[3] || 0;

                const now = Date.now();
                if (now - this.lastUpdate > UPDATE_INTERVAL) {
                    const DEADZONE = 0.3;

                    const movement = {
                        forward: y < -DEADZONE,
                        backward: y > DEADZONE,
                        left: x < -DEADZONE,
                        right: x > DEADZONE,
                        slide_left: false,
                        slide_right: false
                    };

                    const key = JSON.stringify(movement);
                    if (key !== this.lastMovement) {
                        fetch('/move', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: key
                        }).catch(e => console.error('Move error:', e));
                        this.lastMovement = key;
                    }

                    this.lastUpdate = now;
                }
            }
        });

        // =============================================
        // ARM CONTROLLER (Right Hand) - DELTA CONTROL
        // =============================================
        AFRAME.registerComponent('robot-arm-controller', {
            init: function () {
                this.lastUpdate = 0;
                this.lastGripperCheck = 0;
                this.gripperClosed = false;

                // Delta control state - track previous frame
                this.prevPos = null;
                this.prevRot = null;

                // Current robot arm state (in degrees)
                this.armState = {
                    shoulder_pan: 0,
                    shoulder_lift: 0,
                    elbow_flex: 0,
                    wrist_flex: 0,
                    wrist_roll: 0
                };

                // Virtual "hand" position for IK (in arm workspace, meters)
                this.handX = 0.15; // Forward distance
                this.handY = 0.10; // Height above shoulder
                this.pitch = 0;    // Wrist pitch offset
            },

            tick: function () {
                const now = Date.now();

                // Get world position and rotation
                const worldPos = new THREE.Vector3();
                this.el.object3D.getWorldPosition(worldPos);

                const worldQuat = new THREE.Quaternion();
                this.el.object3D.getWorldQuaternion(worldQuat);
                const euler = new THREE.Euler().setFromQuaternion(worldQuat, 'YXZ');

                // --- TRIGGER BUTTON FOR GRIPPER ---
                let triggerValue = 0;
                if (this.el.components['oculus-touch-controls']) {
                    const controller = this.el.components['oculus-touch-controls'].controller;
                    if (controller && controller.gamepad && controller.gamepad.buttons) {
                        // Button 0 is trigger on Quest
                        triggerValue = controller.gamepad.buttons[0]?.value || 0;
                    }
                }

                // Gripper: close when trigger > 0.5
                const shouldClose = triggerValue > 0.5;
                if (shouldClose !== this.gripperClosed && (now - this.lastGripperCheck > 200)) {
                    this.gripperClosed = shouldClose;
                    fetch('/gripper', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ closed: shouldClose })
                    }).catch(e => console.error('Gripper error:', e));
                    this.lastGripperCheck = now;
                }

                // --- DELTA-BASED ARM CONTROL ---
                if (now - this.lastUpdate > UPDATE_INTERVAL) {

                    // Initialize previous position on first frame
                    if (this.prevPos === null) {
                        this.prevPos = worldPos.clone();
                        this.prevRot = euler.clone();
                        this.lastUpdate = now;
                        return;
                    }

                    // Calculate delta from previous frame
                    const deltaX = worldPos.x - this.prevPos.x;
                    const deltaY = worldPos.y - this.prevPos.y;
                    const deltaZ = worldPos.z - this.prevPos.z;

                    const deltaRoll = euler.z - this.prevRot.z;
                    const deltaPitch = euler.x - this.prevRot.x;

                    // Update previous values
                    this.prevPos.copy(worldPos);
                    this.prevRot.copy(euler);

                    // --- APPLY DELTAS ---

                    // Sensitivity scaling factors
                    const POS_SCALE = 0.5;    // Position delta scaling
                    const PAN_SCALE = 150;    // X movement -> shoulder pan (degrees per meter)
                    const ROLL_SCALE = 0.3;   // Roll sensitivity
                    const PITCH_SCALE = 0.3;  // Pitch sensitivity

                    // Delta limits (prevent sudden jumps)
                    const MAX_POS_DELTA = 0.02;  // Max 2cm per frame
                    const MAX_ANGLE_DELTA = 5;  // Max 5 degrees per frame

                    // Clamp deltas
                    const clampedDX = Math.max(-MAX_POS_DELTA, Math.min(MAX_POS_DELTA, deltaX));
                    const clampedDY = Math.max(-MAX_POS_DELTA, Math.min(MAX_POS_DELTA, deltaY));
                    const clampedDZ = Math.max(-MAX_POS_DELTA, Math.min(MAX_POS_DELTA, deltaZ));

                    // Update virtual hand position for IK
                    // VR X (left/right) -> shoulder_pan
                    // VR Y (up/down) -> IK Y (height)
                    // VR Z (forward/back) -> IK X (reach)

                    this.handX += -clampedDZ * POS_SCALE; // Forward reach
                    this.handY += clampedDY * POS_SCALE;  // Height (NOT inverted now)

                    // Clamp hand position to reachable workspace
                    this.handX = Math.max(0.05, Math.min(0.22, this.handX));
                    this.handY = Math.max(-0.10, Math.min(0.15, this.handY));

                    // Shoulder pan from X movement (delta-based)
                    const panDelta = clampedDX * PAN_SCALE;
                    this.armState.shoulder_pan += panDelta;
                    this.armState.shoulder_pan = Math.max(-90, Math.min(90, this.armState.shoulder_pan));

                    // Compute IK for shoulder_lift and elbow_flex
                    const [ikShoulder, ikElbow] = inverseKinematics(this.handX, this.handY);

                    // Smooth transition (alpha blending)
                    const SMOOTH = 0.15;
                    this.armState.shoulder_lift = (1 - SMOOTH) * this.armState.shoulder_lift + SMOOTH * ikShoulder;
                    this.armState.elbow_flex = (1 - SMOOTH) * this.armState.elbow_flex + SMOOTH * ikElbow;

                    // Wrist roll from controller roll
                    const rollDelta = THREE.MathUtils.radToDeg(deltaRoll) * ROLL_SCALE;
                    this.armState.wrist_roll += Math.max(-MAX_ANGLE_DELTA, Math.min(MAX_ANGLE_DELTA, rollDelta));
                    this.armState.wrist_roll = Math.max(-150, Math.min(150, this.armState.wrist_roll));

                    // Wrist pitch from controller pitch
                    const pitchDelta = THREE.MathUtils.radToDeg(deltaPitch) * PITCH_SCALE;
                    this.pitch += Math.max(-MAX_ANGLE_DELTA, Math.min(MAX_ANGLE_DELTA, pitchDelta));
                    this.pitch = Math.max(-90, Math.min(90, this.pitch));

                    // Compensate wrist_flex to keep end effector level
                    // wrist_flex = -shoulder_lift - elbow_flex + pitch
                    this.armState.wrist_flex = -this.armState.shoulder_lift - this.armState.elbow_flex + this.pitch;
                    this.armState.wrist_flex = Math.max(-90, Math.min(90, this.armState.wrist_flex));

                    // Send to robot
                    const payload = {
                        positions: {
                            shoulder_pan: this.armState.shoulder_pan,
                            shoulder_lift: this.armState.shoulder_lift,
                            elbow_flex: this.armState.elbow_flex,
                            wrist_roll: this.armState.wrist_roll,
                            wrist_flex: this.armState.wrist_flex
                        }
                    };

                    fetch('/arm', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    }).catch(e => console.error('Arm error:', e));

                    this.lastUpdate = now;
                }
            }
        });

        // =============================================
        // TEXTURE AUTO-REFRESH
        // =============================================
        AFRAME.registerComponent('auto-refresh-texture', {
            tick: function () {
                const mesh = this.el.getObject3D('mesh');
                if (mesh && mesh.material && mesh.material.map) {
                    mesh.material.map.needsUpdate = true;
                }
            }
        });

    </script>
</body>

</html>