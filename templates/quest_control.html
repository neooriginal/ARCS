<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RoboCrew VR Control</title>
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <style>
        body {
            background-color: #111;
            color: #ccc;
            font-family: sans-serif;
        }

        #overlay {
            position: absolute;
            z-index: 1000;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
        }
    </style>
</head>

<body>
    <div id="overlay">
        <h2>ðŸ¤– RoboCrew VR</h2>
        <p><strong>Left Stick:</strong> Drive | <strong>Right Hand:</strong> Arm | <strong>Trigger:</strong> Gripper</p>
    </div>

    <a-scene background="color: transparent" renderer="alpha: true"
        webxr="optionalFeatures: local-floor, hand-tracking">
        <a-assets>
            <img id="camera-feed" src="/video_feed" crossorigin="anonymous">
        </a-assets>

        <a-plane src="#camera-feed" width="2.5" height="1.875" position="0 1.5 -1.8" auto-refresh-texture></a-plane>

        <a-entity id="rig" position="0 0 0">
            <a-camera position="0 1.6 0" look-controls="pointerLockEnabled: false"></a-camera>
            <a-entity id="leftHand" oculus-touch-controls="hand: left" robot-drive></a-entity>
            <a-entity id="rightHand" oculus-touch-controls="hand: right" robot-arm></a-entity>
        </a-entity>
    </a-scene>

    <script>
        const UPDATE_INTERVAL = 50;

        // =============================================
        // SO101 KINEMATICS - From the example code
        // =============================================
        // Link lengths in meters (approximate for SO101)
        const L1 = 0.105;  // Upper arm
        const L2 = 0.088;  // Forearm
        const L3 = 0.170;  // Combined wrist+gripper

        function inverseKinematics2Link(x, y) {
            // Simple 2-link IK for shoulder_lift and elbow_flex
            // x = forward reach, y = height above shoulder pivot
            const reach = Math.sqrt(x * x + y * y);
            const maxReach = L1 + L2 - 0.01;
            const minReach = 0.05;
            const dist = Math.max(minReach, Math.min(maxReach, reach));

            // Elbow angle via law of cosines
            let cosElbow = (L1 * L1 + L2 * L2 - dist * dist) / (2 * L1 * L2);
            cosElbow = Math.max(-1, Math.min(1, cosElbow));
            const elbowAngle = Math.acos(cosElbow);  // 0 = straight, PI = fully bent

            // Shoulder angle
            const gamma = Math.atan2(y, x);
            let cosAlpha = (L1 * L1 + dist * dist - L2 * L2) / (2 * L1 * dist);
            cosAlpha = Math.max(-1, Math.min(1, cosAlpha));
            const alpha = Math.acos(cosAlpha);

            // shoulder_lift: 0 = horizontal forward
            const shoulderLift = THREE.MathUtils.radToDeg(gamma - alpha);
            // elbow_flex: 0 = straight, negative = bent
            const elbowFlex = THREE.MathUtils.radToDeg(elbowAngle - Math.PI);

            return { shoulderLift, elbowFlex };
        }

        // =============================================
        // DRIVE CONTROLLER (Left Hand)
        // =============================================
        AFRAME.registerComponent('robot-drive', {
            init: function () {
                this.lastUpdate = 0;
                this.lastState = '';
            },
            tick: function () {
                const ctrl = this.el.components['oculus-touch-controls'];
                if (!ctrl || !ctrl.controller || !ctrl.controller.gamepad) return;

                const gp = ctrl.controller.gamepad;
                if (!gp.axes || gp.axes.length < 4) return;

                const now = Date.now();
                if (now - this.lastUpdate < UPDATE_INTERVAL) return;

                const x = gp.axes[2] || 0;
                const y = gp.axes[3] || 0;
                const DZ = 0.3;

                const state = {
                    forward: y < -DZ,
                    backward: y > DZ,
                    left: x < -DZ,
                    right: x > DZ,
                    slide_left: false,
                    slide_right: false
                };

                const stateStr = JSON.stringify(state);
                if (stateStr !== this.lastState) {
                    fetch('/move', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: stateStr
                    }).catch(() => { });
                    this.lastState = stateStr;
                }
                this.lastUpdate = now;
            }
        });

        // =============================================
        // ARM CONTROLLER - ABSOLUTE POSITION MAPPING
        // =============================================
        AFRAME.registerComponent('robot-arm', {
            init: function () {
                this.lastUpdate = 0;
                this.gripperClosed = false;

                // Reference position (captured on first frame)
                this.refPos = null;
                this.refRot = null;

                // Gripper via trigger events
                this.el.addEventListener('triggerdown', () => {
                    this.gripperClosed = true;
                    fetch('/gripper', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ closed: true })
                    }).catch(() => { });
                });

                this.el.addEventListener('triggerup', () => {
                    this.gripperClosed = false;
                    fetch('/gripper', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ closed: false })
                    }).catch(() => { });
                });
            },

            tick: function () {
                const now = Date.now();
                if (now - this.lastUpdate < UPDATE_INTERVAL) return;

                // Get world position and rotation
                const pos = new THREE.Vector3();
                this.el.object3D.getWorldPosition(pos);

                const quat = new THREE.Quaternion();
                this.el.object3D.getWorldQuaternion(quat);
                const euler = new THREE.Euler().setFromQuaternion(quat, 'YXZ');

                // Capture reference on first frame
                if (this.refPos === null) {
                    this.refPos = pos.clone();
                    this.refRot = euler.clone();
                    this.lastUpdate = now;
                    return;
                }

                // =============================================
                // ABSOLUTE POSITION MAPPING
                // =============================================
                // Calculate offset from reference position
                const dx = pos.x - this.refPos.x;  // Left/Right
                const dy = pos.y - this.refPos.y;  // Up/Down
                const dz = pos.z - this.refPos.z;  // Forward/Back (negative = forward)

                // Map to IK workspace
                // Reference = arm at neutral (slightly extended forward)
                const BASE_REACH = 0.12;  // Neutral forward reach
                const BASE_HEIGHT = 0.05; // Neutral height

                // Scale factors for mapping VR movement to robot workspace
                const REACH_SCALE = 0.5;   // How much VR Z affects reach
                const HEIGHT_SCALE = 0.5;  // How much VR Y affects height
                const PAN_SCALE = 90;      // Degrees per meter of X movement
                const ROLL_SCALE = 0.7;    // Wrist roll sensitivity
                const FLEX_SCALE = 0.7;    // Wrist flex sensitivity

                // Calculate arm workspace position
                // Forward hand movement (negative Z) = more reach
                const ikX = BASE_REACH + (-dz * REACH_SCALE);
                const ikY = BASE_HEIGHT + (dy * HEIGHT_SCALE);

                // Clamp to valid workspace
                const clampedX = Math.max(0.05, Math.min(0.18, ikX));
                const clampedY = Math.max(-0.08, Math.min(0.12, ikY));

                // Compute IK
                const { shoulderLift, elbowFlex } = inverseKinematics2Link(clampedX, clampedY);

                // Shoulder pan from X offset
                const shoulderPan = dx * PAN_SCALE;
                const clampedPan = Math.max(-90, Math.min(90, shoulderPan));

                // Wrist rotation from controller rotation (relative to reference)
                const wristRoll = THREE.MathUtils.radToDeg(euler.z - this.refRot.z) * ROLL_SCALE;
                const wristPitch = THREE.MathUtils.radToDeg(euler.x - this.refRot.x) * FLEX_SCALE;

                const clampedRoll = Math.max(-150, Math.min(150, wristRoll));

                // Wrist flex compensates for arm angle to keep gripper level
                // Plus user's pitch input
                const wristFlex = -shoulderLift - elbowFlex + wristPitch;
                const clampedFlex = Math.max(-90, Math.min(90, wristFlex));

                // Send to robot
                const payload = {
                    positions: {
                        shoulder_pan: clampedPan,
                        shoulder_lift: shoulderLift,
                        elbow_flex: elbowFlex,
                        wrist_roll: clampedRoll,
                        wrist_flex: clampedFlex
                    }
                };

                fetch('/arm', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                }).catch(() => { });

                this.lastUpdate = now;
            }
        });

        // =============================================
        // TEXTURE AUTO-REFRESH
        // =============================================
        AFRAME.registerComponent('auto-refresh-texture', {
            tick: function () {
                const mesh = this.el.getObject3D('mesh');
                if (mesh && mesh.material && mesh.material.map) {
                    mesh.material.map.needsUpdate = true;
                }
            }
        });

    </script>
</body>

</html>